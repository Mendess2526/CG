\documentclass[a4paper]{article}
\usepackage[utf8x]{inputenc}
\usepackage[portuguese]{babel}
\usepackage{graphicx}
\usepackage{a4wide}
\usepackage[pdftex,hidelinks]{hyperref}
\usepackage{float}
\usepackage{indentfirst}
\usepackage{subcaption}
\usepackage[cache=false]{minted}
\usepackage{amsmath}
\usepackage{listings}
\usepackage{color}
\usepackage{gensymb}
\usepackage{tikz}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\lstset{frame=tb,
language=C++,
aboveskip=3mm,
belowskip=3mm,
showstringspaces=false,
columns=flexible,
basicstyle={\small\ttfamily},
numbers=none,
numberstyle=\tiny\color{gray},
keywordstyle=\color{blue},
commentstyle=\color{dkgreen},
stringstyle=\color{mauve},
breaklines=true,
breakatwhitespace=true,
tabsize=4
}

\newcommand{\x}{\times}

\begin{document}

\title{Computação Gráfica\\ Animações}
\author{Bárbara Cardoso (a80453) \and Márcio Sousa (a82400) \and Pedro Mendes (a79003)}
\date{\today}

\begin{titlepage}

    %título
    \thispagestyle{empty}
    \begin{center}
        \begin{minipage}{0.75\linewidth}
            \centering
            %engenharia logo
            \includegraphics[width=0.4\textwidth]{eng.jpeg}\par\vspace{1cm}
            \vspace{1.5cm}
            %títulos
            \href{https://www.uminho.pt/PT}{\scshape\LARGE Universidade do Minho} \par
            \vspace{1cm}
            \href{https://www.di.uminho.pt/}{\scshape\Large Departamento de Informática} \par
            \vspace{1.5cm}

            \maketitle
        \end{minipage}
    \end{center}

\end{titlepage}

\tableofcontents

\pagebreak

\section{Introdução}

\section{Generator}

O output do \textit{generator} foi alterado para incluir as normais e
coordenadas de textura correspondentes aos pontos dos triângulos calculados.

\subsection{Plano}
Como um plano está situado no plano xOz e as normais são sempre vetores
perpendiculares, as normais deste são vetores unitários com apenas a componente
y positiva.

As coordenadas de textura para o plano são calculadas de forma
muito simples. Como o plano e a textura tem a mesma forma, o mapeamento é
directo, assim, os cantos da textura são mapeados para os cantos do plano.

\subsection{Cubo}
As normais de um cubo também são simples de calcular, pois cada uma das faces é
paralela a um dos planos (xOz, xOy, yOz), logo as normais dessa face são
perpendiculares ao plano correspondente.

Para as texturas começou-se por definir uma formula que mapeasse as coordenadas
de cada face para valores compreendidos entre, 0 e $\frac{1}{3}$ e 0 e
$\frac{1}{2}$, dependendo do eixo pretendido. Depois é somado um
\textit{offset} a estes valores dependendo da secção da textura que se pretende
mapear.

Assumindo que o ponto de visto é colocado em (0,0,1), as coordenadas de textura
da face da frente são $x \in [0,\frac{1}{3}]$ e $y \in [0,\frac{1}{2}]$ logo o
\textit{offset} destes é nulo. No entanto, para a face da esquerda, as suas
coordenadas de textura são $x \in [\frac{2}{3},1]$ e $y \in [\frac{1}{2},1]$,
logo o \textit{offset} destes é $\frac{2}{3}$ e $\frac{1}{2}$, respectivamente.

% (0,0) ====== (0.333,0) ======= (0.666,0) ===== (1,0)
%   |     F V      |        U      |       R ->  |
% (0,0.5) ==== (0.333,0.5) ===== (0.666,0.5) === |
%   |     B V      |        D      |       L ->  |
% (0,1) ====== (0.333,1) ======= (0.666,1) ===== (1,1)

\subsection{Esfera}\label{sec:esfera}
Sendo que a esfera está sempre centrada na origem, para calcular as normais
desta, é preciso apenas normalizar as coordenadas dos pontos de forma a obter
as normais.

A textura usada para aplicar à esfera é rectangular, devido a isto, o raciocínio
utilizado para aplicar a textura é imaginar que a esfera e cortada em altura e
``espalmada'' sobre a textura, de seguida é apenas necessário mapear
directamente a textura sobre estar interpretação da esfera.

\subsection{Cone}
O calculo das normais do cone é feito em duas partes, primeiro são calculadas
as normais da base, que por definição são o vector unitário $(0,-1,0)$. Para o
lado do cone é calculada o ângulo entre qualquer ponto do lado do cone e a base
do mesmo através de $\arctan(\frac{radius}{stacks})$, este ângulo define a
inclinação das normais laterais. Depois disto basta utilizar coordenadas polares
para determinar as componentes $x$ e $z$ do vector e normalizar.

Para aplicar uma textura a um cone foi definido o formato da
figura~\ref{fig:conetexture}, ou seja, a metade esquerda da imagem é a base do
cone, e a metade direita é a textura do lado do cone. Depois a textura e divida
nas mesmas \textit{slices} e \textit{stacks} que o cone tem e faz-se o
mapeamento.

\begin{figure}[H]
    \centering
    \includegraphics{../assets/cone_rain.png}
    \caption{Textura exemplo de um cone}\label{fig:conetexture}
\end{figure}

\subsection{Torus}
As normais do torus fazem uso da mesma técnica utilizada para a esfera
(Ver~\ref{sec:esfera}) apenas alterado o centro, agora a origem já não é o
ponto de referencia mas sim os centros de cada anel do torus, visto que o
raciocínio para o calculo dos pontos deste já era vectorial, foi apenas
necessário normalizar os vectores.

Para as coordenadas de textura, o mapeamento e similar ao da esfera, imagina se
que a \textit{mesh} to torus e espalmada sobre a textura deste, e assim o
mapeamento e directo. Percorrer a textura ao longo do eixo dos $y$ implica
percorrer o torus a volta do seu perímetro enquanto que no eixo dos $x$
desenha-se cada anel do torus.

\section{Engine}

O \textit{engine} foi estendido para para possibilitar a renderização de
modelos com superfícies mais complexas, permitindo definir se um objeto tem uma
superfície difusa, especular, emissiva e/ou ambiente, assim como definir uma
textura para a cobrir.

\subsection{Sem texturas}
A entrada de um \textit{model} no XML pode agora incluir as componentes acima
referidas através das propriedades \texttt{ambi[RGB]}, \texttt{diff[RGB]},
\texttt{spec[RGB]} e \texttt{emis[RGB]}. Por exemplo,\\
\verb!<model file="models/sphere.3d" ambiR="0.2" diffB="0.8" />!

Todas as componentes tem valores por defeito de $(0,0,0)$ excepto a componente
difusa que tem $(1,1,1)$ por defeito. Num esforço de manter \textit{backwards
compatibility} e cenas de fases anteriores continuarem a funcionar, quando
nenhuma componente é especificada a cor do grupo é passada como valor da
componente emissiva dos seus \textit{models}.

\subsection{Com texturas}

Para além das componentes, pode ser passado também o ficheiro de onde carregar
a textura do modelo utilizando o atributo \texttt{texture}. Por exemplo\\
\verb!<model file="models/sphere.3d" texture="assets/8k_jupiter.jpg" />!

\section{Sistema Solar}

\section{Optimizações}
Para optimizar a utilização de memoria do programa, foi criada uma cache de
modelos e texturas, assim cada conjunto de pontos, normais e coordenadas de
textura, correspondente a um ficheiro \texttt{.3d}, é carregado apenas uma vez
para o GPU e reutilizado para todos os modelos que os utilizam. O mesmo
raciocínio foi feito para as texturas, para que não fosse lido para memória
mais do que uma cópia de cada textura.

Para o caso do sistema solar, como todos os planetas utilizam o mesmo modelo
unitário da esfera, independentemente de quantos astros sejam colocados no
modelo, o ficheiro \texttt{sphere.3d} é lido apenas uma vez.

\section{Conclusões e Trabalho Futuro}

Em conclusão, a area de computação gráfica apresenta desafios bastante diferentes das outras areas de ciências de computação, no que toca a gestão de memória e de recursos de computação, mas também nos conhecimentos de geometria e algebra.

Como trabalho futuro, poderiam ser feitas varias optimizações como oclusão e a utilização de indices para melhorar o desempenho dos VBOs.

\end{document}
